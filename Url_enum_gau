#!/usr/bin/env bash
# url_collect_gau
# Usage:
#   ./url_collect_gau <target> [commands_file] > final_urls.txt
# Example:
#   ./url_collect_gau example.com commands.txt > all_urls.txt
#
# If commands_file is omitted the script runs a sensible default set of gau commands.
# In commands_file each line is a shell command template using {target} as placeholder.
# Lines starting with # or empty lines are ignored.

set -euo pipefail
IFS=$'\n\t'

if [[ $# -lt 1 ]]; then
  >&2 echo "Usage: $0 <target> [commands_file]  (redirect stdout to desired output file)"
  exit 2
fi

TARGET="$1"
CMDFILE="${2:-}"

# check gau exists
if ! command -v gau >/dev/null 2>&1; then
  >&2 echo "ERROR: 'gau' not found in PATH. Install gau and retry."
  exit 3
fi

TMPDIR="$(mktemp -d /tmp/url_collect_gau.XXXX)"
trap 'rm -rf "$TMPDIR"' EXIT

run_cmd_save() {
  local idx="$1"
  local cmd="$2"
  local out="$TMPDIR/step_${idx}.txt"
  # replace {target} placeholder safely
  cmd="${cmd//\{target\}/$TARGET}"

  # run command and capture stdout (allow pipelines)
  >&2 echo "âŸ¶ running: $cmd"
  # use bash -c to support pipes and complex commands; redirect stdout to file
  bash -c "$cmd" >"$out" 2>/dev/null || true
}

# If commands file is provided, read commands from it (ignore comments)
declare -a CMDS
if [[ -n "$CMDFILE" ]]; then
  if [[ ! -f "$CMDFILE" ]]; then
    >&2 echo "ERROR: commands file '$CMDFILE' not found."
    exit 4
  fi
  while IFS= read -r line || [[ -n "$line" ]]; do
    # strip leading/trailing whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"
    # skip empty and comments
    [[ -z "$line" || "${line:0:1}" == "#" ]] && continue
    CMDS+=("$line")
  done <"$CMDFILE"
else
  # default commands
  CMDS+=("gau {target} --subs")
  CMDS+=("gau {target} --subs --blacklist png,jpg,gif,svg,woff,ttf,css,js")
  CMDS+=("gau {target} --subs --mc 200,301,302,403")
  CMDS+=("gau {target} --subs | grep -E '\\?.+='")
  CMDS+=("gau {target} --subs | grep -E '\\?(token|redirect|url)='")
  CMDS+=("gau {target} --subs --from 201801 --to 202312")
  CMDS+=("gau {target} --subs --providers wayback,commoncrawl,urlscan")
  CMDS+=("gau {target} --subs --threads 50")
fi

# run all commands (sequential). If you want parallelism, modify accordingly.
count=0
for c in "${CMDS[@]}"; do
  count=$((count + 1))
  run_cmd_save "$count" "$c"
done

# consolidate outputs: cat all temp files, remove empty lines, remove fragments-only duplicates,
# normalize by removing trailing fragment identifiers (#...), then dedupe and sort.
# You can tweak normalization as needed.
cat "$TMPDIR"/step_*.txt \
  | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' \
  | sed '/^$/d' \
  | sed 's/#.*$//' \
  | sort -u \
  | awk '!seen[$0]++{print}' \
  | sort \
  || true

# print a short stats summary to stderr (counts and where raw outputs are)
{
  echo "----- summary -----"
  echo "target: $TARGET"
  echo "commands run: ${#CMDS[@]}"
  echo "raw outputs saved to: $TMPDIR"
  echo "per-step counts:"
  for f in "$TMPDIR"/step_*.txt; do
    n=$(wc -l <"$f" 2>/dev/null || echo 0)
    echo "  $(basename "$f"): $n lines"
  done
  echo "-------------------"
} >&2

# end
